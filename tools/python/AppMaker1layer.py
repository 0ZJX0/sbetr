#!/usr/bin/env python2
#in app_namePara create two files
#CMakeLists.txt

def Make1layer(sfarm_dir, app_name):
    print "create file "+sfarm_dir+'/'+app_name+'1layer'+"/CMakeLists.txt"
    print "set("+app_name.upper()+"1LAYER_SOURCES"
    print "  "+app_name+"BGCIndexType.F90"
    print "  "+app_name+"BGCType.F90"
    print ")"
    print ""
    print "include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_util)"
    print "include_directories(${CMAKE_BINARY_DIR}/src/betr/betr_math)"
    print "include_directories(${CMAKE_BINARY_DIR}/src/Applications/soil-farm/bgcfarm_util)"
    print "include_directories(${CMAKE_BINARY_DIR}/src/Applications/soil-farm/"+app_name+"/"+app_name+"Para)"
    print "include(add_betr_library)"
    print "add_betr_library("+app_name+"1layer ${"+app_name.upper()+"1LAYER_SOURCES})"
    print ""
    print "set(BETR_LIBRARIES "+app_name+"1layer;${BETR_LIBRARIES} PARENT_SCOPE)"
    print "set(BETR_LIBRARIES "+app_name+"1layer;${BETR_LIBRARIES})"
    print ""
#X#add_subdirectory(tests)
    print "if (NOT CMAKE_INSTALL_PREFIX STREQUAL "+'"'+"INSTALL_DISABLED"+'"'+")"
    print "   install(TARGETS "+app_name+"1layer DESTINATION lib)"
    print "   file(GLOB HEADERS *.h)"
    print "   install(FILES ${HEADERS} DESTINATION include/soil-farm/"+app_name+"/"+app_name+"1layer)"
    print "endif()"
    print ""
    print "create file "+sfarm_dir+'/'+app_name+'1layer'+"/"+app_name+"BGCIndexType.F90"
    print "module "+app_name+"BGCIndexType"
    print "  use bshr_kind_mod  , only : r8 => shr_kind_r8"
    print "  use betr_ctrl      , only : spinup_state => betr_spinup_state"
    print "  use gBGCIndexType  , only : gbgc_index_type"
    print "  use betr_varcon    , only : var_flux_type, var_state_type"
    print "implicit none"
    print "private"
    print "  character(len=*), private, parameter :: mod_filename = &"
    print "       __FILE__"
    print ""
    print "integer, parameter :: loc_name_len=64"
    print ""
    print "  type, public, extends(gbgc_index_type) :: "+app_name+"_index_type"
    print "    integer           :: lit1, lit1_depoly_reac"
    print "    integer           :: lit2, lit2_depoly_reac"
    print "    integer           :: lit3, lit3_depoly_reac"
    print "    integer           :: cwd , cwd_depoly_reac"
    print "    integer           :: lid_n2"
    print "    integer           :: lid_o2   , o2_resp_reac"
    print "    integer           :: lid_ar"
    print "    integer           :: lid_co2"
    print "    integer           :: lid_c13_co2"
    print "    integer           :: lid_c14_co2"
    print "    integer           :: lid_ch4"
    print "  !diagnostic variables"
    print "    integer           :: lid_co2_hr"
    print "    integer           :: lid_o2_paere"
    print "    integer           :: lid_n2_paere"
    print "    integer           :: lid_ar_paere"
    print "    integer           :: lid_co2_paere"
    print "    integer           :: lid_c13_co2_paere"
    print "    integer           :: lid_c14_co2_paere"
    print "    integer           :: lid_ch4_paere"
    print "    integer           :: litr_beg, litr_end  !litr group"
    print "    integer           :: wood_beg, wood_end  !wood group"
    print "    integer           :: dom_beg,  dom_end   !dom group"
    print "    integer           :: Bm_beg,  Bm_end     !microbial group"
    print "    integer           :: nelms"
    print "    integer           :: c_loc, n_loc, p_loc"
    print "    integer           :: c13_loc, c14_loc"
    print "    integer           :: e_loc"
    print "    integer           :: nom_tot_elms"
    print "    integer           :: nom_pools"
    print "    integer           :: nprimvars        !total number of primary variables"
    print "    integer           :: nstvars          !number of equations for the state variabile vector"
    print "    integer           :: nreactions"
    print "    integer , pointer :: primvarid(:)   => null()"
    print "    logical           :: debug"
    print "    character(len=loc_name_len), allocatable :: varnames(:)"
    print "    character(len=loc_name_len), allocatable :: varunits(:)"
    print "    character(len=loc_name_len), allocatable :: ompoolnames(:)"
    print "    integer, allocatable :: vartypes(:)"
    print "  contains"
    print "    procedure, public  :: Init"
    print "    procedure, private :: InitPars"
    print "    procedure, private :: InitAllocate"
    print "    procedure, private :: set_primvar_reac_ids"
    print "  end type "+app_name+"_index_type"
    print "contains"
    print "!-----------------------------------------------------------------------"
    print "  subroutine add_ompool_name(list_name, list_unit, list_pool, prefix, use_c13, use_c14, do_init, vid,uid,pid)"
    print "  !"
    print "  !DESCRIPTION"
    print "  add organic matter pools to the list"
    print "  implicit none"
    print "  type(list_s), pointer :: list_name"
    print "  type(list_s), pointer :: list_unit"
    print "  type(list_s), pointer :: list_pool"
    print "  character(len=*), intent(in) :: prefix"
    print "  logical, intent(in) :: use_c13, use_c14"
    print "  logical, intent(in) :: do_init"
    print "  integer, intent(inout) :: vid"
    print "  integer, intent(inout) :: uid"
    print "  integer, intent(inout) :: pid"
    print "  if(do_init)then"
    print "    call list_init(list_name, trim(prefix)//'_c',vid, itype=var_state_type)"
    print "    call list_init(list_unit, 'mol C m-3',uid)"
    print "    call list_init(list_pool, trim(prefix),pid)"
    print "  else"
    print "    call list_insert(list_name, trim(prefix)//'_c',vid, itype=var_state_type)"
    print "    call list_insert(list_unit, 'mol C m-3',uid)"
    print "    call list_insert(list_pool, trim(prefix),pid)"
    print "  endif"
    print ""
    print "  if(use_c13)then"
    print "    vid=vid+1;call list_insert(list_name, trim(prefix)//'_c13',vid, itype=var_state_type)"
    print "    vid=vid+1;call list_insert(list_unit, 'mol C13 m-3',uid)"
    print "  endif"
    print "  if(use_c14)then"
    print "    vid=vid+1;call list_insert(list_name, trim(prefix)//'_c14',vid, itype=var_state_type)"
    print "    vid=vid+1;call list_insert(list_unit, 'mol C14 m-3',uid)"
    print "  endif"
    print "  end subroutine add_ompool_name"
    print " !-------------------------------------------------------------------------------"
    print "  subroutine Init(this, use_c13, use_c14, non_limit, nop_limit, maxpft)"
    print "  !"
    print "  ! DESCRIPTION:"
    print "  ! Initialize "+app_name+"_index_type"
    print "  ! !USES:"
    print "  implicit none"
    print "  ! !ARGUMENTS:"
    print "  class("+app_name+"_index_type), intent(inout) :: this"
    print "  logical, intent(in) :: use_c13"
    print "  logical, intent(in) :: use_c14"
    print "  logical, intent(in) :: non_limit"
    print "  logical, intent(in) :: nop_limit"
    print "  integer, optional, intent(in) :: maxpft"
    print "  ! !LOCAL VARIABLES:"
    print "  integer :: maxpft_loc"
    print "  maxpft_loc = 0"
    print "  this%dom_beg=0; this%dom_end=-1"
    print "  if(present(maxpft))maxpft_loc=maxpft"
    print "  call this%InitPars(maxpft_loc, use_c14, use_c13, non_limit, nop_limit)"
    print "  call this%InitAllocate()"
    print "  this%debug = .false."
    print "  end subroutine Init"
    print ""
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine InitPars(this, maxpft, use_c14, use_c13, non_limit, nop_limit)"
    print "  !"
    print "  ! !DESCRIPTION:"
    print "  !  describe the layout of the stoichiometric matrix for the reactions"
    print "  !           r{1} r{2} r{3} r{4} ... r{n}"
    print "  ! s{1}"
    print "  ! s{2}"
    print "  ! s{3}"
    print "  ! s{4}"
    print "  ! ..."
    print "  ! s{n}"
    print "  ! s{n+1}  nonreactive primary variables"
    print "  ! s{n+2}"
    print "  ! ..."
    print "  ! s{m}"
    print "  ! s{m+1} diagnostic variables"
    print "  ! s{p}"
    print "  ! each reaction is associated with a primary species, the secondary species follows after primary species"
    print "  !"
    print "  ! !USES:"
    print "  use MathfuncMod   , only : addone, countelm"
    print "  use betr_utils    , only : num2str"
    print "  use betr_constants, only : betr_string_length_long"
    print "  use listMod       , only : copy_name, list_init, list_insert, list_free, copy_name_type"
    print "  implicit none"
    print "  class("+app_name+"_index_type) :: this"
    print "  integer, intent(in) :: maxpft"
    print "  logical, intent(in) :: use_c13"
    print "  logical, intent(in) :: use_c14"
    print "  logical, intent(in) :: non_limit"
    print "  logical, intent(in) :: nop_limit"
    print "  ! !LOCAL VARIABLES:"
    print "  integer :: itemp"
    print "  integer :: ireac   !counter of reactions"
    print "  integer :: itemp0, itemp1"
    print "  integer :: ielem"
    print "  integer :: vid,uid,pid"
    print "  integer :: jj"
    print "  type(list_s), pointer :: list_name => null()"
    print "  type(list_s), pointer :: list_unit => null()"
    print "  type(list_s), pointer :: list_pool => null()"
    print "  type(list_s), pointer :: list_react=> null()"
    print "  character(len=loc_name_len) :: postfix"
    print "  if(maxpft>=0)continue"
    print "  itemp = 0; itemp0=0"
    print "  ireac = 0"
    print "  ielem= 0"
    print "  vid = 0;uid=0;pid=0"
    print "  this%c13_loc=0; this%c14_loc=0"
    print "  this%c_loc = addone(ielem)"
    print "  if(use_c13)then"
    print "    this%c13_loc= addone(ielem)"
    print "  endif"
    print "  if(use_c14)then"
    print "    this%c14_loc=addone(ielem)"
    print "  endif"
    print "  this%nelms = ielem"
    print "  this%e_loc = ielem + 1"
    print ""
    print "  !litter group"
    print "  this%litr_beg=1"
    print "  this%lit1 = addone(itemp);this%lit1_depoly_reac = addone(ireac); call list_init(list_react, 'lit1_depoly_reac', itemp0)"
    print "  call add_ompool_name(list_name, list_unit, list_pool,'lit1', use_c13, use_c14, do_init=.true., vid=vid,uid=uid,pid=pid)"
    print "  this%lit2 = addone(itemp);this%lit2_depoly_reac = addone(ireac); call list_insert(list_react, 'lit2_depoly_reac', itemp0)"
    print "  call add_ompool_name(list_name, list_unit, list_pool,'lit2', use_c13, use_c14, do_init=.false.,vid=vid,uid=uid,pid=pid)"
    print "  this%lit3 = addone(itemp);this%lit3_depoly_reac = addone(ireac); call list_insert(list_react, 'lit3_depoly_reac', itemp0)"
    print "  call add_ompool_name(list_name, list_unit, list_pool,'lit3', use_c13, use_c14, do_init=.false.,vid=vid,uid=uid,pid=pid)"
    print "  this%litr_end = this%litr_beg -1 + (this%lit3-this%lit1+1)*this%nelms"
    print ""
    print "  !woody group"
    print "  this%wood_beg=this%litr_end+1"
    print "  this%cwd  = addone(itemp);this%cwd_depoly_reac  = addone(ireac); call list_insert(list_react, 'cwd_depoly_reac', itemp0)"
    print "  call add_ompool_name(list_name, list_unit, list_pool,'cwd', use_c13, use_c14, do_init=.false., vid=vid,uid=uid,pid=pid)"
    print "  this%wood_end=this%wood_beg-1+(this%cwd-this%cwd+1)*this%nelms"
    print ""
    print "  !microbial biomass group"
    print "  this%Bm_beg=this%wood_end+1"
    print "  !modify the code below accordingly"
    print "  !this%lid_micbl = addone(itemp); this%micbl_mort_reac  = addone(ireac); call list_insert(list_react, 'micbl_mort_reac', itemp0)"
    print "  !call add_ompool_name(list_name, list_unit, list_pool,'MB_live', use_c13, use_c14, do_init=.false., vid=vid,uid=uid,pid=pid)"
    print "  !this%lid_micbd = addone(itemp); this%micbd_depoly_reac = addone(ireac); call list_insert(list_react, 'micbd_depoly_reac', itemp0)"
    print "  !call add_ompool_name(list_name, list_unit, list_pool,'MB_dead', use_c13, use_c14, do_init=.false., vid=vid,uid=uid,pid=pid)"
    print "  !this%Bm_end=this%Bm_beg-1+(this%lid_micbd-this%lid_micbl+1)*this%nelms"
    print "  this%Bm_end=this%Bm_beg"
    print "  !DOM, only one pool is defined at this moment"
    print "  this%dom_beg = this%Bm_end + 1"
    print "  this%lid_dom = addone(itemp);this%dom_uptake_reac  = addone(ireac); call list_insert(list_react, 'dom_uptake_reac', itemp0)"
    print "  call add_ompool_name(list_name, list_unit, list_pool,'DOC', use_c13, use_c14, do_init=.false., vid=vid,uid=uid,pid=pid)"
    print "  this%lid_cue = this%lid_dom + 1"
    print "  call list_insert(list_name, 'DOM_e',vid)"
    print "  call list_insert(list_unit, 'mol e m-3',uid)"
    print "  this%dom_end = this%dom_beg - 1 + (this%lid_dom-this%lid_dom+1)*(this%nelms+1)"
    print ""
    print "  this%nom_pools = (countelm(this%litr_beg, this%litr_end)+&"
    print "     countelm(this%wood_beg,this%wood_end) + &"
    print "     countelm(this%Bm_beg,this%Bm_end))/this%nelms + &"
    print "     countelm(this%dom_beg,this%dom_end)/(this%nelms+1)"
    print ""
    print "  itemp         = countelm(this%litr_beg, this%litr_end)+&"
    print "     countelm(this%wood_beg,this%wood_end) + &"
    print "     countelm(this%Bm_beg,this%Bm_end) + &"
    print "     countelm(this%dom_beg,this%dom_end)"
    print "  this%nom_tot_elms    = itemp"
    print ""
    print "  !non-reactive primary variables"
    print "  this%lid_ar         = addone(itemp);call list_insert(list_name, 'ar',vid, itype=var_state_type); call list_insert(list_unit, 'mol m-3',uid)"
    print ""
    print "  !second primary variables"
    print "  this%lid_o2         = addone(itemp);call list_insert(list_name, 'o2',vid, itype=var_state_type); call list_insert(list_unit, 'mol m-3',uid)"
    print "  this%o2_resp_reac   = addone(ireac); call list_insert(list_react, 'o2_resp_reac', itemp0)"
    print "  this%lid_co2        = addone(itemp);call list_insert(list_name, 'co2',vid, itype=var_state_type);call list_insert(list_unit,'mol m-3',uid)"
    print ""
    print "  if(use_c13)then"
    print "    this%lid_c13_co2  = addone(itemp);call list_insert(list_name, 'c13_co2',vid, itype=var_state_type);call list_insert(list_unit,'mol m-3',uid)"
    print "  endif"
    print "  if(use_c14)then"
    print "    this%lid_c14_co2  = addone(itemp);call list_insert(list_name, 'c14_co2',vid, itype=var_state_type);call list_insert(list_unit,'mol m-3',uid)"
    print "  endif"
    print ""
    print "  this%lid_n2         = addone(itemp);call list_insert(list_name, 'n2',vid, itype=var_state_type); call list_insert(list_unit, 'mol N2 m-3',uid)"
    print "  this%lid_ch4        = addone(itemp);call list_insert(list_name, 'ch4',vid, itype=var_state_type); call list_insert(list_unit, 'mol ch4 m-3',uid)"
    print ""
    print "  this%nprimvars      = itemp"
    print ""
    print "  this%lid_co2_hr     = addone(itemp);call list_insert(list_name, 'co2_hr',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  this%lid_o2_paere  = addone(itemp);call list_insert(list_name, 'o2_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  this%lid_n2_paere  = addone(itemp);call list_insert(list_name, 'n2_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  this%lid_ar_paere  = addone(itemp);call list_insert(list_name, 'ar_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  this%lid_ch4_paere  = addone(itemp);call list_insert(list_name, 'ch4_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  this%lid_co2_paere  = addone(itemp);call list_insert(list_name, 'co2_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  if(use_c13)then"
    print "    this%lid_c13_co2_paere  = addone(itemp);call list_insert(list_name, 'c13_co2_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  endif"
    print "  if(use_c14)then"
    print "    this%lid_co2_paere  = addone(itemp);call list_insert(list_name, 'c14_co2_paere',vid, itype=var_flux_type); call list_insert(list_unit,'mol m-3 s-1',uid)"
    print "  endif"
    print "  this%nstvars          = itemp"
    print "  this%nreactions = ireac"
    print ""
    print "  allocate(this%primvarid(ireac)); this%primvarid(:) = -1"
    print "  allocate(this%vartypes(this%nstvars))"
    print "  allocate(this%varnames(this%nstvars))"
    print "  allocate(this%varunits(this%nstvars))"
    print "  allocate(this%ompoolnames(this%nom_pools))"
    print ""
    print "  call copy_name(this%nstvars, list_name, this%varnames(1:this%nstvars))"
    print "  call copy_name(this%nstvars, list_unit, this%varunits(1:this%nstvars))"
    print "  call copy_name(this%nom_pools, list_pool, this%ompoolnames(1:this%nom_pools))"
    print "  call copy_name_type(this%nstvars, list_name, this%vartypes(1:this%nstvars))"
    print "  !call list_disp(list_name); call list_disp(list_pool);call list_disp(list_unit)"

    print "  call list_free(list_name)"
    print "  call list_free(list_pool)"
    print "  call list_free(list_unit)"
    print "  end subroutine InitPars"
    print ""
    print " !-------------------------------------------------------------------------------"
    print "  subroutine InitAllocate(this)"
    print "  !"
    print "  ! !DESCRIPTION:"
    print "  ! memory allocation for the data type specified by this"
    print "  !"
    print "  implicit none"
    print "  ! !ARGUMENTS:"
    print "  class("+app_name+"_index_type), intent(inout) :: this"
    print ""
    print "  if (this%dummy_compiler_warning) continue"
    print "  end subroutine InitAllocate"
    print ""
    print " !-------------------------------------------------------------------------------"
    print " subroutine set_primvar_reac_ids(this)"
    print " !"
    print " !DESCRIPTION"
    print " !set primary variable for each reaction"
    print " implicit none"
    print " class("+app_name+"_index_type), intent(inout) :: this"
    print ""
    print " !local variables"
    print " integer :: reac"
    print ""
    print " reac=this%lit1_depoly_reac;   this%primvarid(reac) = this%lit1"
    print " reac=this%lit2_depoly_reac;   this%primvarid(reac) = this%lit2"
    print " reac=this%lit3_depoly_reac;   this%primvarid(reac) = this%lit3"
    print " reac=this%cwd_depoly_reac;    this%primvarid(reac) = this%cwd"
    print " reac=this%micbd_depoly_reac;  this%primvarid(reac) = this%lid_micbd"
    print " reac=this%micbl_mort_reac;    this%primvarid(reac) = this%lid_micbl"
    print " reac=this%dom_uptake_reac;    this%primvarid(reac) = this%lid_dom"
    print " reac=this%o2_resp_reac;       this%primvarid(reac) = this%lid_o2"
    print ""
    print " end subroutine set_primvar_reac_ids"
    print "end module "+app_name+"BGCIndexType"
    print ""
    print "create file "+sfarm_dir+'/'+app_name+'1layer'+"/"+app_name+"BGCType.F90"

    print "module "+app_name+"BGCType"
    print "#include "+'"'+"bshr_assert.h"+'"'
    print "  !"
    print "  ! !DESCRIPTION:"
    print ""
    print "  ! !USES:"
    print "  use bshr_kind_mod             , only : r8 => shr_kind_r8"
    print "  use bshr_log_mod              , only : errMsg => shr_log_errMsg"
    print "  use betr_varcon               , only : spval => bspval"
    print "  use betr_ctrl                 , only : spinup_state => betr_spinup_state"
    print "  use gbetrType                 , only : gbetr_type"
    print "  use BiogeoConType             , only : BiogeoCon_type"
    print "  use "+app_name+"ParaType             , only : "+app_name+"_para_type"
    print "  use BetrStatusType            , only : betr_status_type"
    print "  use BeTRJarModel              , only : jar_model_type"
    print "  use "+app_name+"BGCIndexType            , only : "+app_name+"_index_type"
    print "  implicit none"
    print "  private"
    print "  character(len=*), private, parameter :: mod_filename = &"
    print "       __FILE__"
    print ""
    print "  type, extends(jar_model_type), public :: "+app_name+"_bgc_type"
    print "  type("+app_name+"_index_type),     private :: "+app_name+"_index"
    print "    real(r8), pointer                    :: ystates0(:)"
    print "    real(r8), pointer                    :: ystates1(:)"
    print "    real(r8), pointer                    :: scal_f(:)"
    print "    real(r8), pointer                    :: conv_f(:)"
    print "    real(r8), pointer                    :: conc_f(:)"
    print "    logical , private                    :: use_c13"
    print "    logical , private                    :: use_c14"
    print ""
    print "    !declare parameters below"
    print ""
    print "    real(r8), pointer :: cascade_matrix(:,:)"
    print "    real(r8), pointer :: cascade_matrixd(:,:)"
    print "    real(r8), pointer :: cascade_matrixp(:,:)"
    print "    real(r8) :: o2_w2b"
    print "  contains"
    print "    procedure, public  :: init          => init_"+app_name
    print "    procedure, public  :: runbgc        => runbgc_"+app_name
    print "    procedure, public  :: UpdateParas   => UpdateParas_"+app_name
    print "    procedure, public  :: getvarllen    => getvarllen_"+app_name
    print "    procedure, public  :: getvarlist    => getvarlist_"+app_name
    print "    procedure, public  :: init_cold     => init_cold_"+app_name
    print "    procedure, private :: arenchyma_gas_transport"
    print "    procedure, private :: init_states"
    print "    procedure, private :: add_ext_input"
    print "    procedure, private :: InitAllocate"
    print "    procedure, private :: calc_reaction_rates_"+app_name
    print "    procedure, private :: calc_cascade_matrix"
    print "    procedure, private :: bgc_integrate"
    print "    procedure, private :: ode_adapt_ebbks1"
    print "  end type "+app_name+"_bgc_type"

    print "  public :: create_jarmodel_"+app_name+"bgc"
    print "contains"
    print ""
    print "  function create_jarmodel_"+app_name+"bgc()"
    print "  ! DESCRIPTION"
    print "  ! constructor"
    print "    implicit none"
    print "    class("+app_name+"_bgc_type), pointer :: create_jarmodel_"+app_name+"bgc"
    print "    class("+app_name+"_bgc_type), pointer :: bgc"
    print ""
    print "    allocate(bgc)"
    print "    create_jarmodel_"+app_name+"bgc => bgc"
    print ""
    print "  end function create_jarmodel_"+app_name+"bgc"
    print "  !-------------------------------------------------------------------------------"
    print "  function getvarllen_"+app_name+"(this)result(ans)"
    print ""
    print "  implicit none"
    print "  class("+app_name+"_bgc_type) , intent(inout) :: this"
    print "  integer :: ans"
    print "  ans =  this%"+app_name+"_index%nstvars"
    print ""
    print "  end function getvarllen_"+app_name
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine getvarlist_"+app_name+"(this, nstvars, varnames, varunits, vartypes)"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type) , intent(inout) :: this"
    print "  integer, intent(in) :: nstvars"
    print "  character(len=*), intent(out) :: varnames(1:nstvars)"
    print "  character(len=*), intent(out) :: varunits(1:nstvars)"
    print "  integer         , intent(out) :: vartypes(1:nstvars)"
    print "  !local variables"
    print "  integer :: n"
    print ""
    print "  do n = 1, nstvars"
    print "    vartypes(n) = this%"+app_name+"_index%vartypes(n)"
    print "    write(varnames(n),'(A)')trim(this%"+app_name+"_index%varnames(n))"
    print "    write(varunits(n),'(A)')trim(this%"+app_name+"_index%varunits(n))"
    print "  enddo"
    print "  end subroutine getvarlist_"+app_name
    print ""
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine UpdateParas_"+app_name+"(this,  biogeo_con, bstatus)"
    print "  use betr_varcon         , only : betr_maxpatch_pft, betr_max_soilorder"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type) , intent(inout) :: this"
    print "  class(BiogeoCon_type)       , intent(in) :: biogeo_con"
    print "  type(betr_status_type)      , intent(out)   :: bstatus"
    print "  !local variables"
    print "  integer :: sr"
    print "  character(len=256) :: msg"
    print "  call bstatus%reset()"
    print ""
    print "  select type(biogeo_con)"
    print "  type is("+app_name+"_para_type)"
    print "    !pass in parameter values"
    print "  class default"
    print "    write(msg,'(A)')'Wrong parameter type passed in for UpdateParas in ' &"
    print "      // errMsg(mod_filename,__LINE__)"
    print "    call bstatus%set_msg(msg,err=-1)"
    print "    return"
    print "  end select"
    print "  end subroutine UpdateParas_"+app_name
    print "  !-------------------------------------------------------------------------------"
    print ""
    print "  subroutine init_"+app_name+"(this,  biogeo_con,  bstatus)"
    print "  use betr_varcon         , only : betr_maxpatch_pft"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type) , intent(inout) :: this"
    print "  class(BiogeoCon_type)       , intent(in) :: biogeo_con"
    print "  type(betr_status_type)      , intent(out) :: bstatus"
    print "  !local variables"
    print "  character(len=256) :: msg"
    print "  write(this%jarname, '(A)')'"+app_name+"'"
    print ""
    print "  select type(biogeo_con)"
    print "  type is("+app_name+"_para_type)"
    print "    call bstatus%reset()"
    print "    call this%"+app_name+"_index%Init(biogeo_con%use_c13, biogeo_con%use_c14, &"
    print "     biogeo_con%non_limit, biogeo_con%nop_limit, betr_maxpatch_pft)"
    print "    call this%UpdateParas(biogeo_con, bstatus)"
    print "    if(bstatus%check_status())return"
    print ""
    print "    this%use_c13 = biogeo_con%use_c13"
    print "    this%use_c14 = biogeo_con%use_c14"
    print "  class default"
    print "    call bstatus%reset()"
    print "    write(msg,'(A)')'Wrong parameter type passed in for init_"+app_name+" in ' &"
    print "      // errMsg(mod_filename,__LINE__)"
    print "    call bstatus%set_msg(msg,err=-1)"
    print "    return"
    print "  end select"
    print ""
    print "  call this%InitAllocate(this%"+app_name+"_index)"
    print "  end subroutine init_"+app_name
    print "  !-------------------------------------------------------------------------------"
    print ""
    print "  subroutine InitAllocate(this, "+app_name+"_index)"
    print ""
    print "  use betr_varcon         , only : betr_maxpatch_pft, betr_max_soilorder"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)   , intent(inout) :: this"
    print "  type("+app_name+"_index_type)  , intent(in) :: "+app_name+"_index"
    print ""
    print "  associate(                                &"
    print "    nstvars => "+app_name+"_index%nstvars        , &"
    print "    nprimvars=> "+app_name+"_index%nprimvars     , &"
    print "    nreactions => "+app_name+"_index%nreactions    &"
    print "  )"
    print ""
    print "  allocate(this%ystates0(nstvars)); this%ystates0(:) = 0._r8"
    print "  allocate(this%ystates1(nstvars)); this%ystates1(:) = 0._r8"
    print "  allocate(this%scal_f(nprimvars));  this%scal_f(:) = 0._r8"
    print "  allocate(this%conv_f(nprimvars));  this%conv_f(:) = 0._r8"
    print "  allocate(this%conc_f(nprimvars));  this%conc_f(:) = 0._r8"
    print "  allocate(this%cascade_matrix(nstvars, nreactions)); this%cascade_matrix(:,:) = 0._r8"
    print "  allocate(this%cascade_matrixd(1:nprimvars, 1:nreactions)); this%cascade_matrixd(:,:) = 0._r8"
    print "  allocate(this%cascade_matrixp(1:nprimvars, 1:nreactions)); this%cascade_matrixp(:,:) = 0._r8"
    print "  end associate"
    print "  end subroutine InitAllocate"
    print ""
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine runbgc_"+app_name+"(this,  is_surflit, dtime, bgc_forc, nstates, ystates0, ystatesf, bstatus)"
    print ""
    print "  !DESCRIPTION"
    print "  !do bgc model integration for one step"
    print "  use JarBgcForcType        , only : JarBGC_forc_type"
    print "  use MathfuncMod           , only : pd_decomp"
    print "  use BetrStatusType        , only : betr_status_type"
    print "  use MathfuncMod           , only : safe_div"
    print "  use tracer_varcon         , only : catomw, natomw, patomw"
    print "  use MathfuncMod           , only : pd_decomp"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)  , intent(inout) :: this"
    print "  logical                    , intent(in)    :: is_surflit"
    print "  real(r8)                   , intent(in)    :: dtime"
    print "  type(JarBGC_forc_type)     , intent(in)    :: bgc_forc"
    print "  integer                    , intent(in)    :: nstates"
    print "  real(r8)                   , intent(out)   :: ystates0(nstates)"
    print "  real(r8)                   , intent(out)   :: ystatesf(nstates)"
    print "  type(betr_status_type)     , intent(out)   :: bstatus"
    print ""
    print "  !local variables"
    print "  real(r8)               :: time = 0._r8"
    print "  real(r8) :: yf(this%"+app_name+"_index%nstvars)"
    print "  character(len=*),parameter :: subname = 'runbgc_"+app_name
    print ""
    print "  associate(                                         &"
    print "    ystates1       => this%ystates1                , &"
    print "    nstvars        => this%"+app_name+"_index%nstvars     , &"
    print "    nreactions     => this%"+app_name+"_index%nreactions  , &"
    print "    nprimvars      => this%"+app_name+"_index%nprimvars   , &"
    print "    cascade_matrix => this%cascade_matrix          , &"
    print "    cascade_matrixp=> this%cascade_matrixp         , &"
    print "    cascade_matrixd=> this%cascade_matrixd           &"
    print "  )"
    print ""
    print "  call bstatus%reset()"

    print "  !initialize state variables"
    print "  call this%init_states(this%"+app_name+"_index, bgc_forc)"
    print ""
    print "  ystates0(:) = this%ystates0(:)"
    print "  call this%add_ext_input(dtime, this%"+app_name+"_index, bgc_forc)"
    print "  call this%arenchyma_gas_transport(this%"+app_name+"_index, dtime)"
    print "  call this%calc_cascade_matrix(this%"+app_name+"_index,  cascade_matrix)"
    print "  call pd_decomp(nprimvars, nreactions, cascade_matrix(1:nprimvars, 1:nreactions), &"
    print "     cascade_matrixp, cascade_matrixd, bstatus)"
    print "  if(bstatus%check_status())return"
    print ""
    print "  time = 0._r8"
    print "  yf(:) = ystates1(:)"
    print "  call this%ode_adapt_ebbks1(yf, nprimvars, nstvars, time, dtime, ystates1)"
    print ""
    print "  ystatesf(:) = ystates1(:)"
    print ""
    print "  end associate"
    print "  end subroutine runbgc_"+app_name
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine calc_reaction_rates"+app_name+"(this, "+app_name+"_index, dtime,  nstates, ystates1, doc_cue, rrates)"
    print "  !"
    print "  !DESCRIPTION"
    print "  !calculate reaction rates, this subroutine should be customized"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)  , intent(inout) :: this"
    print "  real(r8)               , intent(in)    :: dtime"
    print "  integer                , intent(in)    :: nstates"
    print "  real(r8)               , intent(in)    :: ystates1(nstates)"
    print "  type("+app_name+"_index_type) , intent(in)    :: simic_index"
    print "  real(r8)               , intent(in)    :: doc_cue"
    print "  real(r8)               , intent(out)   :: rrates("+app_name+"_index%nreactions)"
    print "  !local variables"
    print "  integer  :: jj"
    print "  associate(                                            &"
    print "    lit1             => "+app_name+"_index%lit1              , &"
    print "    lit2             => "+app_name+"_index%lit2              , &"
    print "    lit3             => "+app_name+"_index%lit3              , &"
    print "    cwd              => "+app_name+"_index%cwd               , &"
    print "    lid_dom          => "+app_name+"_index%lid_dom           , &"
    print "    lid_o2           => "+app_name+"_index%lid_o2            , &"
    print "    lid_co2          => "+app_name+"_index%lid_co2           , &"
    print "    lit1_depoly_reac => "+app_name+"_index%lit1_depoly_reac  , &"
    print "    lit2_depoly_reac => "+app_name+"_index%lit2_depoly_reac  , &"
    print "    lit3_depoly_reac => "+app_name+"_index%lit3_depoly_reac  , &"
    print "    cwd_depoly_reac  => "+app_name+"_index%cwd_depoly_reac     &"
    print " )"
    print ""
    print "  !assemble the derivatives"
    print "  rrates(:) = 0._r8"
    print "  end associate"
    print "  end subroutine simic_rrates"
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine init_states(this, "+app_name+"_index, bgc_forc)"
    print ""
    print "  use "+app_name+"BGCIndexType            , only : "+app_name+"_index_type"
    print "  use JarBgcForcType            , only : JarBGC_forc_type"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)  , intent(inout) :: this"
    print "  type("+app_name+"_index_type)  , intent(in) :: "+app_name+"_index"
    print "  type(JarBGC_forc_type)  , intent(in) :: bgc_forc"
    print ""
    print "  associate(                               &"
    print "    lid_co2_hr  => "+app_name+"_index%lid_co2_hr, &"
    print "    lid_n2 => "+app_name+"_index%lid_n2,   &"
    print "    lid_o2 => "+app_name+"_index%lid_o2,   &"
    print "    lid_co2 => "+app_name+"_index%lid_co2, &"
    print "    lid_c13_co2 => "+app_name+"_index%lid_c13_co2, &"
    print "    lid_c14_co2 => "+app_name+"_index%lid_c14_co2, &"
    print "    lid_ar => "+app_name+"_index%lid_ar,   &"
    print "    lid_o2_paere => "+app_name+"_index%lid_o2_paere, &"
    print "    lid_n2_paere => "+app_name+"_index%lid_n2_paere, &"
    print "    lid_ar_paere => "+app_name+"_index%lid_ar_paere, &"
    print "    lid_co2_paere => "+app_name+"_index%lid_co2_paere, &"
    print "    lid_ch4_paere => "+app_name+"_index%lid_ch4_paere, &"
    print "    lid_c13_co2_paere => "+app_name+"_index%lid_c13_co2_paere, &"
    print "    lid_c14_co2_paere => "+app_name+"_index%lid_c14_co2_paere, &"
    print "    lid_ch4 => "+app_name+"_index%lid_ch4  &"
    print "  )"
    print ""
    print "  this%ystates0(:) = bgc_forc%ystates(:)"
    print "  this%ystates0(lid_co2_hr) = 0._r8"
    print "  this%ystates1(:) = this%ystates0(:)"
    print ""
    print "  !set conversion parameters for arenchyma transport"
    print "  this%scal_f(lid_n2) = bgc_forc%aren_cond_n2"
    print "  this%conc_f(lid_n2) = bgc_forc%conc_atm_n2"
    print "  this%conv_f(lid_n2) = 1._r8/bgc_forc%n2_g2b"
    print "  this%scal_f(lid_o2) = bgc_forc%aren_cond_o2"
    print "  this%conc_f(lid_o2) = bgc_forc%conc_atm_o2"
    print "  this%conv_f(lid_o2) = 1._r8/bgc_forc%o2_g2b"
    print "  this%scal_f(lid_ar) = bgc_forc%aren_cond_ar"
    print "  this%conc_f(lid_ar) = bgc_forc%conc_atm_ar"
    print "  this%conv_f(lid_ar) = 1._r8/bgc_forc%ar_g2b"
    print "  this%scal_f(lid_co2) = bgc_forc%aren_cond_co2"
    print "  this%conc_f(lid_co2) = bgc_forc%conc_atm_co2"
    print "  this%conv_f(lid_co2) = 1._r8/bgc_forc%co2_g2b"
    print "  if(this%use_c13)then"
    print "    this%scal_f(lid_c13_co2) = bgc_forc%aren_cond_co2_c13"
    print "    this%conc_f(lid_c13_co2) = bgc_forc%conc_atm_co2_c13"
    print "    this%conv_f(lid_c13_co2) = 1._r8/bgc_forc%co2_g2b"
    print "  endif"
    print "  if(this%use_c14)then"
    print "    this%scal_f(lid_c14_co2) = bgc_forc%aren_cond_co2_c14"
    print "    this%conc_f(lid_c14_co2) = bgc_forc%conc_atm_co2_c14"
    print "  endif"
    print "  this%scal_f(lid_ch4) = bgc_forc%aren_cond_ch4"
    print "  this%conc_f(lid_ch4) = bgc_forc%conc_atm_ch4"
    print "  this%conv_f(lid_ch4) = 1._r8/bgc_forc%ch4_g2b"
    print "  end associate"
    print "  end subroutine init_states"
    print "  !--------------------------------------------------------------------"
    print "  subroutine add_ext_input(this, dtime, "+app_name+"_index, bgc_forc)"
    print "  !"
    print "  !DESCRIPTION"
    print "  use "+app_name+"BGCIndexType            , only : "+app_name+"_index_type"
    print "  use JarBgcForcType        , only : JarBGC_forc_type"
    print "  use tracer_varcon             , only : catomw, natomw, patomw,c13atomw,c14atomw"
    print "  use MathfuncMod               , only : safe_div"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)  , intent(inout) :: this"
    print "  real(r8), intent(in) :: dtime"
    print "  type("+app_name+"_index_type)  , intent(in) :: "+app_name+"_index"
    print "  type(JarBGC_forc_type)  , intent(in) :: bgc_forc"
    print ""
    print "  associate(                        &"
    print "    lit1 =>  "+app_name+"_index%lit1, &"
    print "    lit2 =>  "+app_name+"_index%lit2, &"
    print "    lit3 =>  "+app_name+"_index%lit3, &"
    print "    cwd =>   "+app_name+"_index%cwd   &"
    print "   )"
    print ""
    print "  this%ystates1(lit1)=this%ystates0(lit1) +  dtime *  bgc_forc%cflx_input_litr_met"
    print "  this%ystates1(lit2)=this%ystates0(lit2) +  dtime *  bgc_forc%cflx_input_litr_cel"
    print "  this%ystates1(lit3)=this%ystates0(lit3) +  dtime *  bgc_forc%cflx_input_litr_lig"
    print "  this%ystates1(cwd)=this%ystates0(cwd) +  dtime *  bgc_forc%cflx_input_litr_cwd"
    print ""
    print "  end associate"
    print "  end subroutine add_ext_input"
    print ""
    print "  !--------------------------------------------------------------------"
    print "  subroutine arenchyma_gas_transport(this, "+app_name+"_index, dtime)"
    print "  use "+app_name+"BGCIndexType       , only : "+app_name+"_index_type"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)     , intent(inout) :: this"
    print "  type("+app_name+"_index_type)  , intent(in) :: "+app_name+"_index"
    print "  real(r8), intent(in) :: dtime"
    print ""
    print "  !local variables"
    print "  integer :: j"
    print "  real(r8) :: y0"
    print "  associate(                                            &"
    print "    lid_n2            => "+app_name+"_index%lid_n2           , &"
    print "    lid_o2            => "+app_name+"_index%lid_o2           , &"
    print "    lid_co2           => "+app_name+"_index%lid_co2          , &"
    print "    lid_c13_co2       => "+app_name+"_index%lid_c13_co2      , &"
    print "    lid_c14_co2       => "+app_name+"_index%lid_c14_co2      , &"
    print "    lid_ar            => "+app_name+"_index%lid_ar           , &"
    print "    lid_o2_paere      => "+app_name+"_index%lid_o2_paere     , &"
    print "    lid_n2_paere      => "+app_name+"_index%lid_n2_paere     , &"
    print "    lid_ar_paere      => "+app_name+"_index%lid_ar_paere     , &"
    print "    lid_co2_paere     => "+app_name+"_index%lid_co2_paere    , &"
    print "    lid_ch4_paere     => "+app_name+"_index%lid_ch4_paere    , &"
    print "    lid_c13_co2_paere => "+app_name+"_index%lid_c13_co2_paere, &"
    print "    lid_c14_co2_paere => "+app_name+"_index%lid_c14_co2_paere, &"
    print "    lid_ch4           => "+app_name+"_index%lid_ch4            &"
    print "  )"
    print ""
    print "  j = lid_o2; y0=this%ystates1(j)"
    print "  call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "  this%ystates1("+app_name+"_index%lid_o2_paere) = this%ystates1(j)-y0"
    print ""
    print "  if( spinup_state == 0)then"
    print "    j = lid_n2; y0=this%ystates1(j)"
    print "    call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print ""
    print "    this%ystates1("+app_name+"_index%lid_n2_paere) = this%ystates1(j)-y0"
    print "    j = lid_ar; y0=this%ystates1(j)"
    print "    call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "    this%ystates1("+app_name+"_index%lid_ar_paere) = this%ystates1(j)-y0"
    print ""
    print "    j = lid_ch4; y0=this%ystates1(j)"
    print "    call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "    this%ystates1("+app_name+"_index%lid_ch4_paere) = this%ystates1(j)-y0"
    print ""
    print "    j = lid_co2; y0=this%ystates1(j)"
    print "    call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "    this%ystates1("+app_name+"_index%lid_co2_paere) = this%ystates1(j)-y0"
    print ""
    print "    if(this%use_c13)then"
    print "      j = lid_c13_co2; y0=this%ystates1(j)"
    print "      call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "      this%ystates1("+app_name+"_index%lid_c13_co2_paere) = this%ystates1(j)-y0"
    print "    endif"
    print ""
    print "    if(this%use_c14)then"
    print "      j = lid_c14_co2; y0=this%ystates1(j)"
    print "      call exp_ode_int(dtime, this%scal_f(j), this%conv_f(j), this%conc_f(j), this%ystates1(j))"
    print "      this%ystates1("+app_name+"_index%lid_c14_co2_paere) = this%ystates1(j)-y0"
    print "    endif"
    print "  endif"
    print "  end associate"
    print "  contains"
    print "    subroutine exp_ode_int(dt, c1, c2, c3, y0)"
    print "    !"
    print "    ! DESCRIPTION"
    print "    ! solve dy/dt=-c1*(c2*y-c3) using analytic solution"
    print "    implicit none"
    print "    real(r8), intent(in) :: dt"
    print "    real(r8), intent(in) :: c1"
    print "    real(r8), intent(in) :: c2"
    print "    real(r8), intent(in) :: c3"
    print "    real(r8), intent(inout) :: y0"
    print ""
    print "    if(c1>0._r8)then"
    print "      y0 = c3/c2+(y0-c3/c2)*exp(-c1/c2*dtime)"
    print "    endif"
    print "    end subroutine exp_ode_int"
    print "  end subroutine arenchyma_gas_transport"
    print "  !--------------------------------------------------------------------"
    print "  subroutine calc_cascade_matrix(this, "+app_name+"_index,  cascade_matrix)"
    print "  !"
    print "  !DESCRPTION"
    print "  !compute the cascade matrix"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)     , intent(inout) :: this"
    print "  type("+app_name+"_index_type)    , intent(in)    :: "+app_name+"_index"
    print "  real(r8)                  , intent(inout) :: cascade_matrix("+app_name+"_index%nstvars, "+app_name+"_index%nreactions)"
    print "  !local variables"
    print "  integer :: reac"
    print ""
    print "  associate(                                &"
    print "    lit1       => "+app_name+"_index%lit1        , &"
    print "    lit2       => "+app_name+"_index%lit2        , &"
    print "    lit3       => "+app_name+"_index%lit3        , &"
    print "    cwd        => "+app_name+"_index%cwd         , &"
    print "    lid_dom    => "+app_name+"_index%lid_dom     , &"
    print "    lid_micbl  => "+app_name+"_index%lid_micbl   , &"
    print "    lid_micbd  => "+app_name+"_index%lid_micbd   , &"
    print "    lid_cue    => "+app_name+"_index%lid_cue     , &"
    print "    lid_o2     => "+app_name+"_index%lid_o2      , &"
    print "    lid_co2    => "+app_name+"_index%lid_co2     , &"
    print "    lid_co2_hr => "+app_name+"_index%lid_co2_hr  , &"
    print "   ! cue_met    => this%cue_met            , &"
    print "   ! cue_cel    => this%cue_cel            , &"
    print "   ! cue_lig    => this%cue_lig            , &"
    print "   ! cue_cwd    => this%cue_cwd            , &"
    print "   ! f_mic2d    => this%f_mic2d            , &"
    print "   ! f_mic2c    => this%f_mic2c              &"
    print "  )"
    print ""
    print "  reac = "+app_name+"_index%lit1_depoly_reac"
    print "  cascade_matrix(lit1, reac)  = -1._r8"
    print "  cascade_matrix(lid_dom,reac)=1._r8"
    print " ! cascade_matrix(lid_cue,reac)=cue_met"
    print ""
    print "  reac = "+app_name+"_index%lit2_depoly_reac"
    print "  cascade_matrix(lit2, reac)  = -1._r8"
    print "  cascade_matrix(lid_dom,reac)=  1._r8"
    print " ! cascade_matrix(lid_cue,reac)= cue_cel"
    print ""
    print "  reac = "+app_name+"_index%lit3_depoly_reac"
    print "  cascade_matrix(lit3, reac)  = -1._r8"
    print "  cascade_matrix(lid_dom,reac)=1._r8"
    print " ! cascade_matrix(lid_cue,reac)=cue_lig"
    print ""
    print "  reac = "+app_name+"_index%cwd_depoly_reac"
    print "  cascade_matrix(cwd, reac)   = -1._r8"
    print "  cascade_matrix(lid_dom,reac)=1._r8"
    print "  cascade_matrix(lid_cue,reac)=cue_cwd"
    print ""
    print " ! reac = "+app_name+"_index%micbd_depoly_reac"
    print " ! cascade_matrix(lid_micbd, reac)  = -1._r8"
    print " ! cascade_matrix(lid_dom,reac)     = 1._r8"
    print " ! cascade_matrix(lid_cue,reac)     = 0.5_r8"
    print ""
    print " ! reac = "+app_name+"_index%micbl_mort_reac"
    print " ! cascade_matrix(lid_micbl, reac)  = -1._r8"
    print " ! cascade_matrix(lid_micbd,reac)   =  f_mic2D"
    print " ! cascade_matrix(lid_dom,reac)     =  f_mic2C"
    print ""
    print "  reac = "+app_name+"_index%o2_resp_reac"
    print "  cascade_matrix(lid_o2, reac)     = -1._r8"
    print "  cascade_matrix(lid_co2_hr,reac)  =  1._r8"
    print "  cascade_matrix(lid_co2,reac)  =  1._r8"
    print ""
    print "  reac = "+app_name+"_index%doc_uptake_reac"
    print "  cascade_matrix(lid_doc, reac)   = -1._r8"
    print "  cascade_matrix(lid_micbl, reac) = 1._r8"
    print "  end associate"
    print "  end subroutine calc_cascade_matrix"
    print ""
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine ode_adapt_ebbks1(me, y0, nprimeq, neq, t, dt, y)"
    print "    !"
    print "    !DESCRIPTION:"
    print "    !first order implicit bkks ode integration with the adaptive time stepping"
    print "    !This could be used as an example for the implementation of time-adaptive"
    print "    !mbbks1."
    print "    ! !NOTE:"
    print "    ! this code should only be used for mass positive ODE integration"
    print "    use ODEMOD, only : ebbks, get_rerr, get_tscal"
    print "    implicit none"
    print "    ! !ARGUMENTS:"
    print "    class("+app_name+"_bgc_type)     , intent(inout) :: me"
    print "    integer,  intent(in)  :: neq      ! number of equations"
    print "    real(r8), intent(in)  :: y0(neq)  ! state variable at previous time step"
    print "    real(r8), intent(in)  :: t        ! time stamp"
    print "    real(r8), intent(in)  :: dt       ! time stepping"
    print "    integer,  intent(in)  :: nprimeq  ! number of primary variables subject to positivity constraint"
    print "    real(r8), intent(out) :: y(neq)   ! updated state variable"
    print ""
    print "    ! !LOCAL VARIABLES:"
    print "    real(r8) :: yc(neq)    !coarse time stepping solution"
    print "    real(r8) :: yf(neq)    !fine time stepping solution"
    print "    real(r8) :: ycp(neq)   !temporary variable"
    print "    real(r8) :: f(neq)     ! derivative"
    print "    real(r8) :: dt2"
    print "    real(r8) :: dtr"
    print "    real(r8) :: dt05"
    print "    real(r8) :: dtmin"
    print "    real(r8) :: tt,tt2     !temporary variables"
    print "    logical  :: acc"
    print "    real(r8) :: rerr, dt_scal, pscal"
    print "    integer  :: n, nJ"
    print "    real(r8), parameter :: maxtdiv=64._r8"
    print ""
    print "    dt2=dt"
    print "    dtmin=dt/maxtdiv"
    print "    dtr=dt"
    print "    tt=0._r8"
    print "    !make a copy of the solution at the current time step"
    print "    y(:)=y0(:)"
    print "    do"
    print "       if(dt2<=dtmin)then"
    print "         call me%bgc_integrate(y, dt2, tt, nprimeq, neq, f)"
    print "         call ebbks(y, f, nprimeq, neq, dt2, yc, pscal)"
    print "         dtr=dtr-dt2"
    print "         tt=tt+dt2"
    print "         y=yc"
    print "       else"
    print "         !get coarse grid solution"
    print "         call me%bgc_integrate(y, dt2, tt, nprimeq, neq, f)"
    print "         call ebbks(y, f, nprimeq, neq, dt2, yc, pscal)"
    print "         !get fine grid solution"
    print "         dt05=dt2*0.5_r8"
    print "         call ebbks(y,f,nprimeq, neq,dt05, yf, pscal)"
    print "         tt2=tt+dt05"
    print "         ycp=yf"
    print "         call me%bgc_integrate(ycp, dt05, tt, nprimeq, neq, f)"
    print "         call ebbks(ycp,f,nprimeq, neq,dt05,yf,pscal)"
    print "         !determine the relative error"
    print "         rerr=get_rerr(yc,yf, neq)*exp(1._r8-1._r8/(pscal+1.e-20))"
    print "         !determine time scalar factor"
    print "         call get_tscal(rerr,dt_scal,acc)"
    print "         if(acc)then"
    print "           dtr=dtr-dt2"
    print "           tt=tt+dt2"
    print "           y=yf"
    print "         endif"
    print "         dt2=dt2*dt_scal"
    print "         dt2=min(dt2,dtr)"
    print "       endif"
    print "       if(abs(dtr/dt)<1.e-4_r8)exit"
    print "    enddo"
    print "  end subroutine ode_adapt_ebbks1"
    print ""
    print "  !--------------------------------------------------------------------"
    print "  subroutine bgc_integrate(this, ystate, dtime, time, nprimvars, nstvars, dydt)"
    print "  !"
    print "  !DESCRPTION"
    print "  core code for integrating the bgc system"
    print "  use SOMStateVarUpdateMod , only : calc_dtrend_som_bgc"
    print "  use MathfuncMod          , only : lom_type, safe_div"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)     , intent(inout) :: this"
    print "  integer                   , intent(in) :: nstvars"
    print "  integer                   , intent(in) :: nprimvars"
    print "  real(r8)                  , intent(in) :: dtime"
    print "  real(r8)                  , intent(in) :: time"
    print "  real(r8)                  , intent(in) :: ystate(nstvars)"
    print "  real(r8)                  , intent(out) :: dydt(nstvars)"
    print "  !local variables"
    print "  integer  :: jj, it"
    print "  integer, parameter  :: itmax = 10"
    print "  type(lom_type) :: lom"
    print "  type(betr_status_type) :: bstatus"
    print "  logical :: lneg"
    print "  real(r8) :: rscal(1:this%"+app_name+"_index%nreactions)"
    print "  real(r8) :: rrates(1:nstvars)"
    print "  real(r8) :: p_dt(1:nprimvars)"
    print "  real(r8) :: d_dt(1:nprimvars)"
    print "  real(r8) :: pscal(1:nprimvars)"
    print "  !real(r8) :: doc_cue"
    print ""
    print "  associate(                                            &"
    print "    !lid_cue        => this%"+app_name+"_index%lid_cue        , &"
    print "    lid_dom        => this%"+app_name+"_index%lid_dom        , &"
    print "    doc_uptake_reac=> this%"+app_name+"_index%doc_uptake_reac, &"
    print "    nreactions => this%"+app_name+"_index%nreactions           &"
    print "  )"
    print ""
    print "  !customize the following lines"
    print "  !doc_cue = safe_div(ystate(lid_cue), ystate(lid_doc))"
    print "  !call this%calc_rrates"+app_name+"(this%simic_index, dtime, nstvars, ystate, doc_cue, rrates)"
    print "  !this%cascade_matrixd(lid_cue, doc_uptake_reac) =  doc_cue"
    print "  !this%cascade_matrix(lid_cue, doc_uptake_reac)  = -doc_cue"
    print ""
    print "  it=0"
    print "  rscal=0._r8"
    print "  do"
    print "    call calc_dtrend_som_bgc(nprimvars, nreactions, this%cascade_matrixp(1:nprimvars, 1:nreactions), rrates, p_dt)"
    print "    call calc_dtrend_som_bgc(nprimvars, nreactions, this%cascade_matrixd(1:nprimvars, 1:nreactions), rrates, d_dt)"
    print "    !update the state variables"
    print "    call lom%calc_state_pscal(nprimvars, dtime, ystate(1:nprimvars), p_dt(1:nprimvars),  d_dt(1:nprimvars), &"
    print "        pscal(1:nprimvars), lneg, bstatus)"
    print "    if(lneg .and. it<=itmax)then"
    print "      call lom%calc_reaction_rscal(nprimvars, nreactions,  pscal(1:nprimvars), &"
    print "        this%cascade_matrixd(1:nprimvars, 1:nreactions),rscal, bstatus)"
    print "      call lom%apply_reaction_rscal(nreactions, rscal(1:nreactions), rrates(1:nreactions))"
    print "    else"
    print "      call calc_dtrend_som_bgc(nstvars, nreactions, this%cascade_matrix(1:nstvars, 1:nreactions), &"
    print "         rrates(1:nreactions), dydt)"
    print "      exit"
    print "    endif"
    print "    it = it + 1"
    print "  enddo"
    print "  end associate"
    print "  end subroutine bgc_integrate"
    print "  !-------------------------------------------------------------------------------"
    print "  subroutine init_cold_"+app_name+"(this, nstvars, ystates)"
    print "  !"
    print "  !DESCRPTION"
    print "  !do a cold state initialization for batch mode simulation"
    print "  implicit none"
    print "  class("+app_name+"_bgc_type)     , intent(inout) :: this"
    print "  integer                   , intent(in)    :: nstvars"
    print "  real(r8)                  , intent(inout) :: ystates(nstvars)"
    print ""
    print "  !Initialize necessary state variables below"
    print "  end subroutine init_cold_"+app_name
    print "  end module "+app_name+"BGCType"
